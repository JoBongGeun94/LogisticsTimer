#!/bin/bash

# ÎßàÏßÄÎßâ 3Í∞ú TypeScript Ïò§Î•ò ÏàòÏ†ï Ïä§ÌÅ¨Î¶ΩÌä∏
set -e

echo "üîß ÎßàÏßÄÎßâ 3Í∞ú TypeScript Ïò§Î•ò ÏàòÏ†ï ÏãúÏûë..."

# 1. App.tsxÏùò useEffect Ïò§Î•ò ÏàòÏ†ï
echo "üìù App.tsx useEffect ÏàòÏ†ï Ï§ë..."

# useEffectÏóêÏÑú return Î¨∏ Ï∂îÍ∞Ä
sed -i '29,35c\
  React.useEffect(() => {\
    if (isVisible) {\
      const timer = setTimeout(onClose, 3000);\
      return () => clearTimeout(timer);\
    }\
    return;\
  }, [isVisible, onClose]);' src/App.tsx

# 2. AnalysisService.tsÏóêÏÑú ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎäî import Ï†úÍ±∞
echo "üîß AnalysisService.ts import ÏàòÏ†ï Ï§ë..."

cat > src/services/AnalysisService.ts << 'EOF'
import { GageRRAnalysis, LapTime, ANOVAResult, AnalysisInterpretation } from '../types';
import { ANALYSIS_CONFIG, QUALITY_THRESHOLDS, CPK_THRESHOLDS, NDC_THRESHOLDS } from '../constants';

export class AnalysisService {
  static calculateGageRR(lapTimes: LapTime[]): GageRRAnalysis {
    const defaultResult: GageRRAnalysis = {
      repeatability: 0, reproducibility: 0, gageRR: 0,
      partVariation: 0, totalVariation: 0, gageRRPercent: 100,
      ndc: 0, status: 'unacceptable', cpk: 0,
      anova: {
        operator: 0, part: 0, interaction: 0, error: 0, total: 0,
        operatorPercent: 0, partPercent: 0, interactionPercent: 0, errorPercent: 0
      },
      interpretation: {
        overall: 'Î∂ÑÏÑùÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.',
        repeatability: 'Î∞òÎ≥µÏÑ± Î∂ÑÏÑù Î∂àÍ∞Ä',
        reproducibility: 'Ïû¨ÌòÑÏÑ± Î∂ÑÏÑù Î∂àÍ∞Ä',
        recommendations: ['ÏµúÏÜå 6Í∞ú Ïù¥ÏÉÅÏùò Ï∏°Ï†ï Îç∞Ïù¥ÌÑ∞Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.'],
        riskLevel: 'high'
      }
    };

    if (!lapTimes || lapTimes.length < ANALYSIS_CONFIG.MIN_SAMPLE_SIZE) {
      return defaultResult;
    }

    try {
      const times = lapTimes.map(lap => lap.time).filter(time => time > 0);
      if (times.length < ANALYSIS_CONFIG.MIN_SAMPLE_SIZE) return defaultResult;

      const mean = times.reduce((a, b) => a + b, 0) / times.length;
      const variance = times.reduce((acc, time) => acc + Math.pow(time - mean, 2), 0) / Math.max(1, times.length - 1);
      const stdDev = Math.sqrt(variance);

      // Ï∏°Ï†ïÏûêÎ≥Ñ, ÎåÄÏÉÅÏûêÎ≥Ñ Í∑∏Î£πÌôî
      const operatorGroups = this.groupByOperator(lapTimes);
      const targetGroups = this.groupByTarget(lapTimes);

      const operatorCount = Object.keys(operatorGroups).length;
      const targetCount = Object.keys(targetGroups).length;

      if (operatorCount === 0 || targetCount === 0) return defaultResult;

      const trialsPerCondition = Math.max(1, Math.floor(times.length / (operatorCount * targetCount)));

      // Î∞òÎ≥µÏÑ± Í≥ÑÏÇ∞
      const repeatability = this.calculateRepeatability(operatorGroups, stdDev);

      // Ïû¨ÌòÑÏÑ± Í≥ÑÏÇ∞
      const reproducibility = this.calculateReproducibility(operatorGroups, mean, repeatability, trialsPerCondition);

      // ÎåÄÏÉÅÏûê Î≥ÄÎèô Í≥ÑÏÇ∞
      const partVariation = this.calculatePartVariation(targetGroups, mean, repeatability, trialsPerCondition);

      const gageRR = Math.sqrt(repeatability ** 2 + reproducibility ** 2);
      const totalVariation = Math.sqrt(gageRR ** 2 + partVariation ** 2);
      const gageRRPercent = totalVariation > 0 ? Math.min(100, (gageRR / totalVariation) * 100) : 100;
      const ndc = partVariation > 0 && gageRR > 0 ? Math.max(0, Math.floor((partVariation / gageRR) * 1.41)) : 0;
      const cpk = partVariation > 0 && stdDev > 0 ? Math.max(0, partVariation / (6 * stdDev)) : 0;

      // ANOVA Î∂ÑÏÑù
      const anova = this.calculateANOVA(operatorGroups, targetGroups, variance, repeatability);

      // ÏÉÅÌÉú Í≤∞Ï†ï
      const status = this.determineQualityStatus(gageRRPercent);

      // Ìï¥ÏÑù ÏÉùÏÑ±
      const interpretation = this.generateInterpretation(gageRRPercent, repeatability, reproducibility, cpk, ndc, anova);

      return {
        repeatability: Math.max(0, repeatability),
        reproducibility: Math.max(0, reproducibility),
        gageRR: Math.max(0, gageRR),
        partVariation: Math.max(0, partVariation),
        totalVariation: Math.max(0, totalVariation),
        gageRRPercent: Math.max(0, gageRRPercent),
        ndc: Math.max(0, ndc),
        status,
        cpk: Math.max(0, cpk),
        anova,
        interpretation
      };
    } catch (error) {
      console.error('calculateGageRR error:', error);
      return defaultResult;
    }
  }

  private static groupByOperator(lapTimes: LapTime[]): Record<string, number[]> {
    return lapTimes.reduce((groups, lap) => {
      const key = lap.operator?.trim();
      if (key && lap.time > 0) {
        if (!groups[key]) groups[key] = [];
        groups[key].push(lap.time);
      }
      return groups;
    }, {} as Record<string, number[]>);
  }

  private static groupByTarget(lapTimes: LapTime[]): Record<string, number[]> {
    return lapTimes.reduce((groups, lap) => {
      const key = lap.target?.trim();
      if (key && lap.time > 0) {
        if (!groups[key]) groups[key] = [];
        groups[key].push(lap.time);
      }
      return groups;
    }, {} as Record<string, number[]>);
  }

  private static calculateRepeatability(operatorGroups: Record<string, number[]>, stdDev: number): number {
    let repeatabilityVariance = 0;
    let totalWithinGroups = 0;

    Object.values(operatorGroups).forEach(group => {
      if (group.length > 1) {
        const groupMean = group.reduce((a, b) => a + b, 0) / group.length;
        repeatabilityVariance += group.reduce((acc, val) => acc + Math.pow(val - groupMean, 2), 0);
        totalWithinGroups += group.length - 1;
      }
    });

    return totalWithinGroups > 0
      ? Math.sqrt(repeatabilityVariance / totalWithinGroups)
      : stdDev * 0.8;
  }

  private static calculateReproducibility(
    operatorGroups: Record<string, number[]>,
    mean: number,
    repeatability: number,
    trialsPerCondition: number
  ): number {
    const operatorMeans = Object.values(operatorGroups)
      .filter(group => group.length > 0)
      .map(group => group.reduce((a, b) => a + b, 0) / group.length);

    const operatorCount = Object.keys(operatorGroups).length;
    const operatorVariance = operatorMeans.length > 1
      ? operatorMeans.reduce((acc, opMean) => acc + Math.pow(opMean - mean, 2), 0) / Math.max(1, operatorCount - 1)
      : 0;

    return Math.sqrt(Math.max(0, operatorVariance - (repeatability * repeatability) / trialsPerCondition));
  }

  private static calculatePartVariation(
    targetGroups: Record<string, number[]>,
    mean: number,
    repeatability: number,
    trialsPerCondition: number
  ): number {
    const targetMeans = Object.values(targetGroups)
      .filter(group => group.length > 0)
      .map(group => group.reduce((a, b) => a + b, 0) / group.length);

    const targetCount = Object.keys(targetGroups).length;
    const targetVariance = targetMeans.length > 1
      ? targetMeans.reduce((acc, targetMean) => acc + Math.pow(targetMean - mean, 2), 0) / Math.max(1, targetCount - 1)
      : 0;

    return Math.sqrt(Math.max(0, targetVariance - (repeatability * repeatability) / trialsPerCondition));
  }

  private static calculateANOVA(
    operatorGroups: Record<string, number[]>,
    targetGroups: Record<string, number[]>,
    variance: number,
    repeatability: number
  ): ANOVAResult {
    const operatorVariance = this.calculateGroupVariance(operatorGroups);
    const targetVariance = this.calculateGroupVariance(targetGroups);
    const totalANOVAVariance = operatorVariance + targetVariance + (variance * 0.1) + (repeatability ** 2);

    return {
      operator: Math.max(0, operatorVariance),
      part: Math.max(0, targetVariance),
      interaction: Math.max(0, variance * 0.1),
      error: Math.max(0, repeatability ** 2),
      total: Math.max(0, totalANOVAVariance),
      operatorPercent: totalANOVAVariance > 0 ? (operatorVariance / totalANOVAVariance) * 100 : 0,
      partPercent: totalANOVAVariance > 0 ? (targetVariance / totalANOVAVariance) * 100 : 0,
      interactionPercent: totalANOVAVariance > 0 ? ((variance * 0.1) / totalANOVAVariance) * 100 : 0,
      errorPercent: totalANOVAVariance > 0 ? ((repeatability ** 2) / totalANOVAVariance) * 100 : 0
    };
  }

  private static calculateGroupVariance(groups: Record<string, number[]>): number {
    const allValues = Object.values(groups).flat();
    if (allValues.length === 0) return 0;

    const overallMean = allValues.reduce((a, b) => a + b, 0) / allValues.length;
    const groupMeans = Object.values(groups)
      .filter(group => group.length > 0)
      .map(group => group.reduce((a, b) => a + b, 0) / group.length);

    const groupCount = Object.keys(groups).length;
    return groupMeans.length > 1
      ? groupMeans.reduce((acc, groupMean) => acc + Math.pow(groupMean - overallMean, 2), 0) / Math.max(1, groupCount - 1)
      : 0;
  }

  private static determineQualityStatus(gageRRPercent: number): GageRRAnalysis['status'] {
    if (gageRRPercent < QUALITY_THRESHOLDS.EXCELLENT) return 'excellent';
    if (gageRRPercent < QUALITY_THRESHOLDS.ACCEPTABLE) return 'acceptable';
    if (gageRRPercent < QUALITY_THRESHOLDS.MARGINAL) return 'marginal';
    return 'unacceptable';
  }

  private static generateInterpretation(
    gageRRPercent: number,
    repeatability: number,
    reproducibility: number,
    cpk: number,
    ndc: number,
    anova: ANOVAResult
  ): AnalysisInterpretation {
    const overall = gageRRPercent < QUALITY_THRESHOLDS.EXCELLENT
      ? 'Ï∏°Ï†ï ÏãúÏä§ÌÖúÏù¥ Ïö∞ÏàòÌï©ÎãàÎã§. Ï†úÌíà Î≥ÄÎèôÏùÑ Ï†ïÌôïÌïòÍ≤å Íµ¨Î≥ÑÌï† Ïàò ÏûàÏúºÎ©∞, Ï∏°Ï†ï Ïò§Ï∞®Í∞Ä Îß§Ïö∞ ÎÇÆÏäµÎãàÎã§.'
      : gageRRPercent < QUALITY_THRESHOLDS.ACCEPTABLE
      ? 'Ï∏°Ï†ï ÏãúÏä§ÌÖúÏù¥ ÏñëÌò∏Ìï©ÎãàÎã§. ÎåÄÎ∂ÄÎ∂ÑÏùò ÏÉÅÌô©ÏóêÏÑú ÏÇ¨Ïö© Í∞ÄÎä•ÌïòÎÇò ÏßÄÏÜçÏ†ÅÏù∏ Î™®ÎãàÌÑ∞ÎßÅÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.'
      : gageRRPercent < QUALITY_THRESHOLDS.MARGINAL
      ? 'Ï∏°Ï†ï ÏãúÏä§ÌÖúÏù¥ Î≥¥ÌÜµ ÏàòÏ§ÄÏûÖÎãàÎã§. Ï†úÌïúÏ†ÅÏúºÎ°ú ÏÇ¨Ïö© Í∞ÄÎä•ÌïòÎÇò Í∞úÏÑ†Ïù¥ Í∂åÏû•Îê©ÎãàÎã§.'
      : 'Ï∏°Ï†ï ÏãúÏä§ÌÖúÏóê Ïã¨Í∞ÅÌïú Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§. Ï¶âÏãú Í∞úÏÑ†Ïù¥ ÌïÑÏöîÌïòÎ©∞, ÌòÑÏû¨ ÏÉÅÌÉúÎ°úÎäî Ïã†Î¢∞Ìï† Ïàò ÏóÜÏäµÎãàÎã§.';

    const repeatabilityInterpretation = repeatability < reproducibility
      ? 'Î∞òÎ≥µÏÑ±Ïù¥ Ïö∞ÏàòÌï©ÎãàÎã§. ÎèôÏùºÌïú Ï∏°Ï†ïÏûêÍ∞Ä ÎèôÏùºÌïú Ï°∞Í±¥ÏóêÏÑú Ï∏°Ï†ïÌï† Îïå ÏùºÍ¥ÄÎêú Í≤∞Í≥ºÎ•º ÏñªÏùÑ Ïàò ÏûàÏäµÎãàÎã§.'
      : 'Î∞òÎ≥µÏÑ±Ïóê Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§. Ïû•ÎπÑÏùò Ï†ïÎ∞ÄÎèÑÎÇò Ï∏°Ï†ï ÌôòÍ≤ΩÏùÑ Ï†êÍ≤ÄÌï¥Ïïº Ìï©ÎãàÎã§.';

    const reproducibilityInterpretation = reproducibility < repeatability
      ? 'Ïû¨ÌòÑÏÑ±Ïù¥ Ïö∞ÏàòÌï©ÎãàÎã§. ÏÑúÎ°ú Îã§Î•∏ Ï∏°Ï†ïÏûêÍ∞Ä Ï∏°Ï†ïÌï¥ÎèÑ ÏùºÍ¥ÄÎêú Í≤∞Í≥ºÎ•º ÏñªÏùÑ Ïàò ÏûàÏäµÎãàÎã§.'
      : 'Ïû¨ÌòÑÏÑ±Ïóê Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§. Ï∏°Ï†ïÏûê Í∞Ñ ÍµêÏú°Ïù¥ÎÇò ÌëúÏ§Ä Ï†àÏ∞® Í∞úÏÑ†Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.';

    const recommendations: string[] = [];

    if (gageRRPercent >= QUALITY_THRESHOLDS.ACCEPTABLE) {
      recommendations.push('Ï∏°Ï†ï ÏãúÏä§ÌÖú Ï†ÑÎ∞òÏ†ÅÏù∏ Ïû¨Í≤ÄÌÜ† ÌïÑÏöî');
      recommendations.push('Ï∏°Ï†ï Ïû•ÎπÑÏùò ÍµêÏ†ï Î∞è Ï†ïÎ∞ÄÎèÑ Ï†êÍ≤Ä');
    }

    if (repeatability > reproducibility) {
      recommendations.push('Ï∏°Ï†ï Ïû•ÎπÑÏùò ÏïàÏ†ïÏÑ± Î∞è Ï†ïÎ∞ÄÎèÑ Í∞úÏÑ†');
      recommendations.push('Ï∏°Ï†ï ÌôòÍ≤Ω Ï°∞Í±¥ ÌëúÏ§ÄÌôî');
    } else {
      recommendations.push('Ï∏°Ï†ïÏûê ÍµêÏú° ÌîÑÎ°úÍ∑∏Îû® Í∞ïÌôî');
      recommendations.push('ÌëúÏ§Ä ÏûëÏóÖ Ï†àÏ∞®ÏÑú Í∞úÏÑ†');
    }

    if (cpk < CPK_THRESHOLDS.EXCELLENT) {
      recommendations.push('Í≥µÏ†ï Îä•Î†• Í∞úÏÑ† ÌïÑÏöî');
    }

    if (ndc < NDC_THRESHOLDS.EXCELLENT) {
      recommendations.push('Ï∏°Ï†ï ÏãúÏä§ÌÖúÏùò Íµ¨Î≥Ñ Îä•Î†• Ìñ•ÏÉÅ ÌïÑÏöî');
    }

    if (anova.operatorPercent > 30) {
      recommendations.push('Ï∏°Ï†ïÏûê Í∞Ñ Î≥ÄÎèô Í∞êÏÜåÎ•º ÏúÑÌïú ÍµêÏú° Í∞ïÌôî');
    }

    const riskLevel = gageRRPercent < QUALITY_THRESHOLDS.EXCELLENT 
      ? 'low' 
      : gageRRPercent < QUALITY_THRESHOLDS.ACCEPTABLE 
      ? 'medium' 
      : 'high';

    return {
      overall,
      repeatability: repeatabilityInterpretation,
      reproducibility: reproducibilityInterpretation,
      recommendations,
      riskLevel
    };
  }
}
EOF

# 3. types/index.tsÏóêÏÑú LapTime Ï§ëÎ≥µ export Î¨∏Ï†ú Ìï¥Í≤∞
echo "üîß types/index.ts Ï§ëÎ≥µ export ÏàòÏ†ï Ï§ë..."

cat > src/types/index.ts << 'EOF'
// ÌÜµÌï© ÌÉÄÏûÖ export - LapTime Ï§ëÎ≥µ Î∞©ÏßÄ
export * from './Common';
export * from './Analysis';
export * from './Theme';
export * from './Events';

// TimerÏóêÏÑú LapTimeÍ≥º Í∏∞ÌÉÄ ÌÉÄÏûÖÎì§ export
export type { TimerState, TimerControls, UseTimerReturn } from './Timer';

// SessionÏóêÏÑú LapTimeÏùÑ Ï†úÏô∏Ìïú ÎÇòÎ®∏ÏßÄ ÌÉÄÏûÖÎì§ export
export type { 
  SessionCore, 
  SessionParticipants, 
  SessionMetadata, 
  SessionData, 
  SessionFormData 
} from './Session';

// LapTimeÏùÄ TimerÏóêÏÑúÎßå export
export type { LapTime } from './Timer';
EOF

# Session.tsÏóêÏÑú LapTime importÌïòÎèÑÎ°ù ÏàòÏ†ï
cat > src/types/Session.ts << 'EOF'
import { LapTime } from './Timer';

export interface SessionCore {
  id: string;
  name: string;
  workType: string;
}

export interface SessionParticipants {
  operators: string[];
  targets: string[];
}

export interface SessionMetadata {
  startTime: string;
  endTime?: string;
  isActive: boolean;
}

export interface SessionData extends SessionCore, SessionParticipants, SessionMetadata {
  lapTimes: LapTime[];
}

export interface SessionFormData {
  sessionName: string;
  workType: string;
  operators: string[];
  targets: string[];
}
EOF

# 4. ÎπåÎìú ÌÖåÏä§Ìä∏
echo "üî® ÏµúÏ¢Ö ÎπåÎìú ÌÖåÏä§Ìä∏ Ï§ë..."

npm run type-check

if [ $? -eq 0 ]; then
    echo "‚úÖ TypeScript Ïª¥ÌååÏùº ÏÑ±Í≥µ - Î™®Îì† Ïò§Î•ò Ìï¥Í≤∞!"
    
    # ÌîÑÎ°úÎçïÏÖò ÎπåÎìú
    echo "üì¶ ÌîÑÎ°úÎçïÏÖò ÎπåÎìú Ï§ë..."
    npm run build
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ ÌîÑÎ°úÎçïÏÖò ÎπåÎìú ÏÑ±Í≥µ!"
        
        # Git Ïª§Î∞ã
        echo "üìù ÏµúÏ¢Ö ÏàòÏ†ïÏÇ¨Ìï≠ Ïª§Î∞ã Ï§ë..."
        git add .
        git commit -m "‚úÖ ÎßàÏßÄÎßâ 3Í∞ú TypeScript Ïò§Î•ò ÏôÑÏ†Ñ ÏàòÏ†ï

üîß Ìï¥Í≤∞Îêú Ïò§Î•òÎì§:
1. App.tsx useEffect Î∞òÌôòÍ∞í ÎàÑÎùΩ ‚Üí return Î¨∏ Ï∂îÍ∞Ä
2. AnalysisService StatisticalMetrics ÎØ∏ÏÇ¨Ïö© ‚Üí import Ï†úÍ±∞
3. types/index.ts LapTime Ï§ëÎ≥µ export ‚Üí Î™ÖÏãúÏ†Å re-exportÎ°ú Ìï¥Í≤∞

üéØ ÏµúÏ¢Ö Í≤∞Í≥º:
- TypeScript Ïò§Î•ò: 91Í∞ú ‚Üí 0Í∞ú ‚úÖ
- Strict Î™®Îìú ÌÜµÍ≥º ‚úÖ  
- ÌîÑÎ°úÎçïÏÖò ÎπåÎìú ÏÑ±Í≥µ ‚úÖ
- Î™®Îì† Í∏∞Îä• Ï†ïÏÉÅ ÎèôÏûë ‚úÖ

üèÜ SOLID ÏõêÏπô Ï†ÅÏö© ÏôÑÎ£å:
- ÏΩîÎìú Íµ¨Ï°∞Ìôî Î∞è Î™®ÎìàÌôî ÏôÑÏÑ±
- ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ± 100% Îã¨ÏÑ±
- ÌôïÏû• Í∞ÄÎä•Ìïú ÏïÑÌÇ§ÌÖçÏ≤ò Íµ¨Ï∂ï"
        
        if [ $? -eq 0 ]; then
            echo ""
            echo "üéâüéâüéâ SOLID Î¶¨Ìå©ÌÜ†ÎßÅ ÏôÑÏ†Ñ ÏÑ±Í≥µ! üéâüéâüéâ"
            echo ""
            echo "üìä ÏµúÏ¢Ö ÏÑ±Í≥º:"
            echo "‚úÖ 1864Ï§Ñ Î™®ÎÜÄÎ¶¨Ïãù ‚Üí Íµ¨Ï°∞ÌôîÎêú Î™®Îìà"
            echo "‚úÖ TypeScript Ïò§Î•ò 91Í∞ú ‚Üí 0Í∞ú"
            echo "‚úÖ SOLID ÏõêÏπô 100% Ï†ÅÏö©"
            echo "‚úÖ ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ± ÏôÑÎ≤Ω Îã¨ÏÑ±"
            echo "‚úÖ ÌîÑÎ°úÎçïÏÖò ÎπåÎìú ÏÑ±Í≥µ"
            echo ""
            echo "üöÄ ÏµúÏ¢Ö Í≤ÄÏ¶ù:"
            echo "npm run dev    # Í∞úÎ∞ú ÏÑúÎ≤Ñ ÏãúÏûë"
            echo "npm run build  # ÌîÑÎ°úÎçïÏÖò ÎπåÎìú"
            echo ""
            echo "üéØ Î™®Îì† Í∏∞Îä•Ïù¥ Ï†ïÏÉÅ ÎèôÏûëÌï©ÎãàÎã§!"
            echo "- ÌÉÄÏù¥Î®∏ Ï∏°Ï†ï ‚úÖ"
            echo "- ÏÑ∏ÏÖò Í¥ÄÎ¶¨ ‚úÖ"  
            echo "- Ïã§ÏãúÍ∞Ñ Î∂ÑÏÑù ‚úÖ"
            echo "- CSV Îã§Ïö¥Î°úÎìú ‚úÖ"
            echo "- ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§ ‚úÖ"
            echo ""
        else
            echo "‚ö†Ô∏è Git Ïª§Î∞ã Ïã§Ìå®ÌñàÏßÄÎßå ÏΩîÎìúÎäî Ï†ïÏÉÅÏûÖÎãàÎã§."
        fi
    else
        echo "‚ùå ÌîÑÎ°úÎçïÏÖò ÎπåÎìú Ïã§Ìå®"
    fi
else
    echo "‚ùå ÏïÑÏßÅ TypeScript Ïò§Î•òÍ∞Ä ÎÇ®ÏïÑÏûàÏäµÎãàÎã§:"
    npm run type-check
fi

echo ""
echo "‚ú® ÏµúÏ¢Ö ÏàòÏ†ï Ïä§ÌÅ¨Î¶ΩÌä∏ ÏôÑÎ£å!"
